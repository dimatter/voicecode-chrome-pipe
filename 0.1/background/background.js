// Generated by CoffeeScript 1.10.0
(function() {
  var HintDispenser, VoiceCodeBackground, throttledMethods,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  VoiceCodeBackground = (function() {
    var instance;

    instance = null;

    function VoiceCodeBackground() {
      if (instance != null) {
        return instance;
      }
      instance = this;
    }

    VoiceCodeBackground.prototype.getIdentity = function() {};

    return VoiceCodeBackground;

  })();

  HintDispenser = (function() {
    var instance, ledger, register;

    instance = null;

    ledger = {};

    register = function(tabId, frameId, hint) {
      var base;
      if (ledger[tabId] == null) {
        ledger[tabId] = {};
      }
      if ((base = ledger[tabId])[frameId] == null) {
        base[frameId] = [];
      }
      return ledger[tabId][frameId].push(parseInt(hint));
    };

    function HintDispenser() {
      this.reserveHint = bind(this.reserveHint, this);
      this.getHint = bind(this.getHint, this);
      if (instance != null) {
        return instance;
      }
      instance = this;
    }

    HintDispenser.prototype.getAggregate = function(tabId) {
      if (ledger[tabId] == null) {
        ledger[tabId] = {};
      }
      return _.flatten(_.toArray(ledger[tabId]));
    };

    HintDispenser.prototype.getHints = function(arg) {
      var count, frameId, hints, tabId;
      tabId = arg.tabId, frameId = arg.frameId, count = arg.count;
      hints = _.times(count, (function(_this) {
        return function() {
          return _this.getHint({
            tabId: tabId,
            frameId: frameId
          });
        };
      })(this));
      return {
        hints: _.flatten(hints)
      };
    };

    HintDispenser.prototype.getHint = function(arg) {
      var base, frameId, hint, tabId;
      tabId = arg.tabId, frameId = arg.frameId;
      if (ledger[tabId] == null) {
        ledger[tabId] = {};
      }
      if ((base = ledger[tabId])[frameId] == null) {
        base[frameId] = [];
      }
      hint = 0;
      while (this.alreadyTaken(hint, tabId)) {
        ++hint;
      }
      register(tabId, frameId, hint);
      return {
        hint: hint
      };
    };

    HintDispenser.prototype.reset = function(arg) {
      var frameId, tabId;
      tabId = arg.tabId, frameId = arg.frameId;
      if (frameId != null) {
        ledger[tabId][frameId] = [];
        return;
      }
      return ledger[tabId] = {};
    };

    HintDispenser.prototype.reserveHints = function(arg) {
      var frameId, reservations, tabId;
      tabId = arg.tabId, frameId = arg.frameId, reservations = arg.reservations;
      reservations = _.map(reservations, (function(_this) {
        return function(arg1) {
          var desiredInteger, id;
          desiredInteger = arg1.desiredInteger, id = arg1.id;
          return _this.reserveHint({
            tabId: tabId,
            frameId: frameId,
            desiredInteger: desiredInteger,
            id: id
          });
        };
      })(this));
      return {
        reservations: reservations
      };
    };

    HintDispenser.prototype.alreadyTaken = function(desiredInteger, tabId) {
      var ref;
      return ref = parseInt(desiredInteger), indexOf.call(this.getAggregate(tabId), ref) >= 0;
    };

    HintDispenser.prototype.reserveHint = function(arg) {
      var desiredInteger, frameId, id, tabId;
      tabId = arg.tabId, frameId = arg.frameId, desiredInteger = arg.desiredInteger, id = arg.id;
      if (!this.alreadyTaken(desiredInteger, tabId)) {
        register(tabId, frameId, desiredInteger);
        return {
          id: id,
          hint: desiredInteger,
          overwritten: false
        };
      }
      return {
        id: id,
        hint: (this.getHint({
          tabId: tabId,
          frameId: frameId
        })).hint,
        overwritten: true
      };
    };

    return HintDispenser;

  })();

  chrome.tabs.onUpdated.addListener((function(_this) {
    return function(tabId, changeInfo, tab) {
      var message;
      if (changeInfo.url != null) {
        message = {
          type: 'invokeBound',
          namespace: 'voiceCodeForeground',
          method: 'urlChanged'
        };
        chrome.tabs.sendMessage(tabId, message);
      }
      if (changeInfo.status === 'complete') {
        message = {
          type: 'invokeBound',
          namespace: 'voiceCodeForeground',
          method: 'loadComplete'
        };
        chrome.tabs.sendMessage(tabId, message);
      }
      if (changeInfo.status === 'loading') {
        return hintDispenser.reset({
          tabId: tabId
        });
      }
    };
  })(this));

  throttledMethods = 'clearSearchQuery';

  chrome.runtime.onMessage.addListener((function(_this) {
    return function(request, sender, sendResponse) {
      var argumentsObject, base, base1, instance, method, namespace, ref, ref1, results, senderInfo, tabId;
      console.debug('<', request, sender);
      senderInfo = {
        frameId: sender.frameId,
        tabId: sender.tab.id,
        windowId: sender.tab.windowId
      };
      switch (request.destination) {
        case 'tab':
          tabId = (ref = request.parameters.tabId) != null ? ref : null;
          if (tabId == null) {
            tabId = senderInfo.tabId;
          }
          if ((base = request.parameters).argumentsObject == null) {
            base.argumentsObject = {};
          }
          chrome.tabs.sendMessage(tabId, _.extend(request.parameters, {
            type: request.type
          }));
          break;
        case 'backend':
          if (indexOf.call(throttledMethods, method) >= 0 && parseInt(frameId) !== 0) {
            return false;
          }
          if ((base1 = request.parameters).callbackArguments == null) {
            base1.callbackArguments = {};
          }
          request.parameters.callbackArguments = _.extend(request.parameters.callbackArguments, senderInfo);
          _this.socket.send({
            type: request.type,
            parameters: request.parameters
          });
          break;
        case 'background':
          ref1 = request.parameters, namespace = ref1.namespace, method = ref1.method, argumentsObject = ref1.argumentsObject;
          if (argumentsObject == null) {
            argumentsObject = {};
          }
          argumentsObject = _.extend(argumentsObject, senderInfo);
          switch (request.type) {
            case 'invoke':
              results = _this[namespace][method].call(_this, argumentsObject);
              break;
            case 'invokeBound':
              instance = new _this[namespace];
              results = instance[method].call(instance, argumentsObject);
          }
          sendResponse(_.extend(results || {}, senderInfo));
      }
      return false;
    };
  })(this));

  this.socket = new WebSocketWrapper;

  this.hintDispenser = new HintDispenser;

  this.voiceCodeBackground = new VoiceCodeBackground;

  this.HintDispenser = HintDispenser;

}).call(this);
