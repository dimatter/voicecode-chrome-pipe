// Generated by CoffeeScript 1.10.0
(function() {
  var config, requestHandler, webSocketWrapper;

  config = {
    host: 'localhost',
    port: 7441,
    heartbeat: 10000
  };

  requestHandler = (function() {
    var validRequests;

    validRequests = ['ping', 'getState'];

    function requestHandler(socket, data1) {
      this.socket = socket;
      this.data = data1;
      this.parse(this.data);
    }

    requestHandler.prototype.parse = function(data) {
      var argumentList, callbackArguments, callbackName, error, error1, error2, method, namespace, parameters, ref, request;
      try {
        ref = JSON.parse(data), request = ref.request, parameters = ref.parameters;
        console.log(request);
        console.log(parameters);
        switch (request) {
          case 'execute':
            namespace = parameters.namespace, method = parameters.method, argumentList = parameters.argumentList, callbackName = parameters.callbackName, callbackArguments = parameters.callbackArguments;
            try {
              argumentList.push((function(_this) {
                return function() {
                  if ((callbackArguments != null) && callbackArguments.length) {
                    callbackArguments = _.object(callbackArguments, arguments);
                  } else {
                    callbackArguments = arguments;
                  }
                  return _this.socket.send({
                    type: 'executionCallback',
                    parameters: {
                      namespace: namespace,
                      method: method,
                      callbackName: callbackName,
                      callbackArguments: callbackArguments
                    }
                  });
                };
              })(this));
              return chrome[namespace][method].apply(this, argumentList);
            } catch (error1) {
              error = error1;
            }
            break;
          case 'eventListener':
            namespace = parameters.namespace, method = parameters.method, callbackArguments = parameters.callbackArguments;
            return chrome[namespace][method].addListener((function(_this) {
              return function() {
                if (!_this.socket.alive) {
                  chrome[namespace][method].removeListener(_this);
                  return;
                }
                if ((callbackArguments != null) && callbackArguments.length) {
                  callbackArguments = _.object(callbackArguments, arguments);
                } else {
                  callbackArguments = arguments;
                }
                return _this.socket.send({
                  type: 'eventListenerCallback',
                  parameters: {
                    namespace: namespace,
                    event: method,
                    callbackArguments: callbackArguments
                  }
                });
              };
            })(this));
        }
      } catch (error2) {
        error = error2;
        return this.socket.send({
          type: 'error',
          parameters: {
            error: error
          }
        });
      }
    };

    return requestHandler;

  })();

  webSocketWrapper = (function() {
    function webSocketWrapper() {
      this.heartbeat = null;
      this.socket = new WebSocket('ws://' + config.host + ':' + config.port + '/');
      this.alive = false;
      this.socket.onopen = (function(_this) {
        return function() {
          console.log("Connected!");
          _this.alive = true;
          return _this.heartbeat = setInterval(function() {
            return _this.send({
              type: 'heartbeat',
              parameters: {}
            });
          }, config.heartbeat);
        };
      })(this);
      this.socket.onmessage = (function(_this) {
        return function(event) {
          return new requestHandler(_this, event.data);
        };
      })(this);
      this.socket.onerror = (function(_this) {
        return function() {
          return _this.socket.close();
        };
      })(this);
      this.socket.onclose = (function(_this) {
        return function() {
          return _this.close();
        };
      })(this);
    }

    webSocketWrapper.prototype.send = function(payload) {
      return this.socket.send(JSON.stringify(payload));
    };

    webSocketWrapper.prototype.close = function() {
      var attribute, i, len, ref;
      console.log('Socket closed');
      clearInterval(this.heartbeat);
      this.alive = false;
      ref = ['heartbeat', 'socket'];
      for (i = 0, len = ref.length; i < len; i++) {
        attribute = ref[i];
        delete this[attribute];
      }
      delete window.socket;
      return setTimeout(function() {
        return window.socket = new webSocketWrapper;
      }, config.heartbeat);
    };

    return webSocketWrapper;

  })();

  window.socket = new webSocketWrapper;

}).call(this);
