// Generated by CoffeeScript 1.10.0
(function() {
  var DomCache, SelectionController,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  DomCache = (function() {
    var instance;

    instance = null;

    function DomCache() {
      if (instance != null) {
        return instance;
      }
      this.visibleTextNodes = [];
      voiceCodeForeground.installListener(window, 'resize', (function(_this) {
        return function() {
          return _this.rescan();
        };
      })(this));
      voiceCodeForeground.installListener(window, 'scroll', (function(_this) {
        return function() {
          return _this.rescan();
        };
      })(this));
      DomUtilities.documentReady((function(_this) {
        return function() {
          return _this.rescan();
        };
      })(this));
      instance = this;
    }

    DomCache.prototype.rescan = function() {
      this.clear();
      return this.searchVisibleTextNodes();
    };

    DomCache.prototype.clear = function() {
      return this.visibleTextNodes = [];
    };

    DomCache.prototype.searchVisibleTextNodes = function() {
      var node, results, text, treeWalker, visitedNodes;
      visitedNodes = [];
      treeWalker = document.createTreeWalker(document.body, NodeFilter.SHOW_TEXT);
      results = [];
      while (node = treeWalker.nextNode()) {
        if (node.nodeType !== 3) {
          continue;
        }
        if (indexOf.call(visitedNodes, node) >= 0) {
          continue;
        }
        text = node.data.trim();
        if (!(0 < text.length)) {
          continue;
        }
        visitedNodes.push(node);
        if (DomUtilities.getVisibleClientRect(node.parentNode)) {
          results.push(this.visibleTextNodes.push(node));
        } else {
          results.push(void 0);
        }
      }
      return results;
    };

    return DomCache;

  })();


  /**
   * type: String: select/extend
   */

  SelectionController = (function() {
    var instance;

    instance = null;

    function SelectionController() {
      if (instance != null) {
        return instance;
      }
      instance = this;
      this.cache = {};
      this.currentPosition = {};
      this.previousSearchTerm = null;
      voiceCodeForeground.installListener(window, 'click', (function(_this) {
        return function(event) {
          return _this.reset();
        };
      })(this));
    }

    SelectionController.prototype.select = function(argumentsObject) {
      var direction, ender, found, funky, mode, ref, startFrom, starter, target, wheneverFound;
      ref = _.extend({
        direction: 'forward',
        mode: 'select'
      }, argumentsObject), target = ref.target, direction = ref.direction, mode = ref.mode;
      if (target === null) {
        target = this.previousSearchTerm;
      }
      if (target == null) {
        console.error("Nothing to search for!");
        return;
      }
      if (document.getSelection().type === 'Range' && _.isEmpty(this.currentPosition)) {
        starter = null;
        _.find(domCache.visibleTextNodes, function(node, position) {
          if (document.getSelection().focusNode === node) {
            starter = position;
            return true;
          }
          return false;
        });
        if (document.getSelection().extentNode !== document.getSelection().baseNode) {
          ender = null;
          _.find(domCache.visibleTextNodes.reverse(), function(node, position) {
            if (document.getSelection().extentNode === node) {
              ender = position;
              return true;
            }
            return false;
          });
          domCache.visibleTextNodes.reverse();
        } else {
          ender = starter;
        }
        if ((starter != null) && (ender != null)) {
          this.range = document.getSelection().getRangeAt(0);
          this.reset();
          this.currentPosition = {
            forward: starter,
            backward: ender
          };
        }
      }
      found = null;
      funky = (function(_this) {
        return function(node, position) {
          var expression, findings, leftEdgePush, rightEdgePush;
          if (direction === 'forward') {
            expression = target;
          } else {
            expression = "(" + target + ")(?![\\s\\S]*" + target + "[\\s\\S]*)";
          }
          if (target === _this.previousSearchTerm && !_.isEmpty(_this.currentPosition)) {
            if (direction === 'forward') {
              if (node === _this.range.endContainer) {
                leftEdgePush = _this.range.endOffset;
                expression = "([\\s\\S]{" + leftEdgePush + ",})" + target;
              }
            } else {
              if (node === _this.range.startContainer) {
                rightEdgePush = node.textContent.length - _this.range.startOffset;
                expression = target + "[\\s\\S]{" + rightEdgePush + ",}$";
              }
            }
          }
          expression = new RegExp(expression, 'mi');
          findings = expression.exec(node.textContent);
          if (findings != null) {
            found = {
              node: node,
              position: position,
              offset: findings.index
            };
            return true;
          }
          return false;
        };
      })(this);
      if (direction === 'forward') {
        startFrom = this.currentPosition[direction] || 0;
        wheneverFound = (function(_this) {
          return function(found) {
            var base;
            if ((base = _this.currentPosition)[direction] == null) {
              base[direction] = 0;
            }
            return _this.currentPosition[direction] += found.position;
          };
        })(this);
        _.find(domCache.visibleTextNodes.slice(startFrom), funky);
      } else {
        startFrom = this.currentPosition[direction] || this.currentPosition['forward'] + 1 || _.size(domCache.visibleTextNodes);
        wheneverFound = (function(_this) {
          return function(found) {
            var base;
            if ((base = _this.currentPosition)[direction] == null) {
              base[direction] = _this.currentPosition['forward'] || _.size(domCache.visibleTextNodes);
            }
            return _this.currentPosition[direction] -= found.position;
          };
        })(this);
        _.find(domCache.visibleTextNodes.slice(0, startFrom).reverse(), funky);
      }
      if (found != null) {
        wheneverFound(found);
        if (mode === 'select') {
          this.deselectAll();
          this.range = document.createRange();
          this.range.setStart(found.node, found.offset);
          this.range.setEnd(found.node, found.offset + target.length);
        } else {
          if (direction === 'forward') {
            this.range.setEnd(found.node, found.offset + target.length);
          } else {
            this.range.setStart(found.node, found.offset);
          }
        }
        document.getSelection().addRange(this.range);
        return this.previousSearchTerm = target;
      }
    };

    SelectionController.prototype.extend = function(argumentsObject) {
      return this.select(_.extend(argumentsObject, {
        mode: 'extend'
      }));
    };

    SelectionController.prototype.reset = function() {
      return this.currentPosition = {};
    };

    SelectionController.prototype.deselectAll = function() {
      return document.getSelection().removeAllRanges();
    };

    return SelectionController;

  })();

  window.SelectionController = new SelectionController;

  window.domCache = new DomCache;

}).call(this);
